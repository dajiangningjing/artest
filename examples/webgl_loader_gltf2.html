<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - glTF loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            color: #fff;
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
        }

        #info a {
            color: #75ddc1;
            font-weight: bold;
        }
    </style>
</head>

<body>


    <script src="../build/three.js"></script>

    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/loaders/GLTFLoader.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <!-- 兴趣点数据 -->
    <script src="./POI.js"></script>

    <!-- 84坐标系转笛卡尔坐标系 -->
    <script src="./geodecy.js"></script>

    <script src="http://libs.baidu.com/jquery/1.9.1/jquery.js"></script>


    <script>
        if (!Detector.webgl) Detector.addGetWebGLMessage();

        var container, stats, controls;
        var camera, scene, renderer, light;
        var mixer = null;
        var deg = 0;
        var t0;
        const CONTROL_VCAM_DIRECT = true;
        var currentTagIdx = 0;
        const FPS = 18;
        var renderT = 1 / FPS; //单位秒 间隔多长时间渲染渲染一次
        // 声明一个变量表示render()函数被多次调用累积时间
        // 如果执行一次renderer.render，timeS重新置0
        var timeS = 0;

        var clock = new THREE.Clock();

        console.log(POIs);
        processPOIs(POIs);


        hw_gotoHomePosition();

        init();
        animate();

        function hw_gotoHomePosition() {
            var url = 'http://127.0.0.1:3000/gotoHomePosition'
            $.get(url, (data, status) => {
                console.log(data);
            })
        }

        function hw_continuousMove(xspeed, yspeed, zoom, callback) {
            var url = `http://127.0.0.1:3000/continuousMove?xspeed=${xspeed}&yspeed=${yspeed}&zoom=${zoom}`
            $.get(url, (data, status) => {
                if (callback) {
                    callback(data);
                }
            })
        }

        function init() {
            t0 = new Date();

            container = document.createElement('div');
            document.body.appendChild(container);



            scene = new THREE.Scene();

            // envmap
            var path = 'textures/cube/Bridge2/';
            var format = '.jpg';
            var envMap = new THREE.CubeTextureLoader().load([
                path + 'posx' + format, path + 'negx' + format,
                path + 'posy' + format, path + 'negy' + format,
                path + 'posz' + format, path + 'negz' + format
            ]);

            scene = new THREE.Scene();
            scene.background = envMap;

            light = new THREE.HemisphereLight(0xbbbbff, 0x444422);
            light.position.set(0, 1, 0);
            scene.add(light);


            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.gammaOutput = true;
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);
            addPOI(POIs);
            // stats
            stats = new Stats();
            container.appendChild(stats.dom);

            window.addEventListener('keydown', keyPressed, false);
            window.addEventListener('keyup', keyUp, false);

        }

        var onoff = 0;
        var h = 0,
            v = 0;

        function keyUp(e) {
            //     console.log('key up');
            onoff = 0;
            v = h = 0;
        }

        function keyPressed(e) {
            // console.log('key press');
            onoff = 1;
            var key = event.keyCode;
            switch (key) {

                case 87:
                    /*w*/
                    v = 1;
                    if (CONTROL_VCAM_DIRECT) {
                        camera.rotateX(v * Math.PI / 2000);
                    } else {

                    }
                    break;

                case 65:
                    /*a*/
                    h = 1;
                    if (CONTROL_VCAM_DIRECT) {
                        rotDeltaByworldY(h);
                    } else {
                        hw_continuousMove(1, 0, 0, data => {
                            console.log(data.position.x * 180);
                            gotoHomePosition();
                            rotDeltaByworldY(-data.position.x * 180);

                        });

                    }
                    //rotDeltaByworldY(-1);
                    break;

                case 83:
                    /*s*/
                    v = -1;
                    if (CONTROL_VCAM_DIRECT) {
                        camera.rotateX(v * Math.PI / 2000);
                    } else {

                    }
                    break;
                case 68:
                    /*d*/
                    h = -1;

                    if (CONTROL_VCAM_DIRECT) {
                        rotDeltaByworldY(h);


                    } else {
                        hw_continuousMove(-1, 0, 0, data => {
                            console.log(data.position.x * 180);
                            gotoHomePosition();
                            rotDeltaByworldY(-data.position.x * 180);
                        });
                    }
                    break;
                case 82: //r
                    //reset
                    gotoHomePosition();
                    break;
                case 84: //t
                    //lookat
                    lookAtTag(POIs.tags[currentTagIdx]);
                    currentTagIdx = (currentTagIdx + 1) % POIs.tags.length;
                    break;
            }
        }

        /*
         * 水平转动
         * degree -180~180
         * 右手坐标系, 逆时针转动为正 
         */
        function rotDeltaByworldY(degree) {
            // var quaternion = new THREE.Quaternion();
            // quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), degInRad(degree));
            // camera.quaternion.multiplyQuaternions(quaternion, camera.quaternion);

            camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), degInRad(degree));
            console.log(eulerToAngle(quatToEuler(camera.quaternion).y))

        }
        /**
         * 回到初始位置, POI tag0 默认为正北方向
         */
        function gotoHomePosition() {
            camera.lookAt(new THREE.Vector3(POIs.tags[0].pos.x, POIs.tags[0].pos.y,
                POIs.tags[0].pos.z));
        }

        /**
         * Look at tag and calc x_angle, y_angle
         */
        function lookAtTag(tag) {
            camera.lookAt(new THREE.Vector3(tag.pos.x, tag.pos.y,
                tag.pos.z));

            var pantilt = {
                x: eulerToAngle(quatToEuler(camera.quaternion).y),
                y: eulerToAngle(quatToEuler(camera.quaternion).x)
            }
            console.log(pantilt)
            return pantilt;
        }


        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        //
        function degInRad(deg) {
            return deg * Math.PI / 180;
        }


        // Pass the obj.quaternion that you want to convert here:
        //*********************************************************
        function quatToEuler(q1) {
            var pitchYawRoll = new THREE.Vector3();
            sqw = q1.w * q1.w;
            sqx = q1.x * q1.x;
            sqy = q1.y * q1.y;
            sqz = q1.z * q1.z;
            unit = sqx + sqy + sqz + sqw; // if normalised is one, otherwise is correction factor
            test = q1.x * q1.y + q1.z * q1.w;
            if (test > 0.499 * unit) { // singularity at north pole
                heading = 2 * Math.atan2(q1.x, q1.w);
                attitude = Math.PI / 2;
                bank = 0;
                return;
            }
            if (test < -0.499 *
                unit) { // singularity at south pole heading=-2 * Math.atan2(q1.x, q1.w); attitude=-Math.PI / 2;
                bank = 0;
                return;
            } else {
                heading = Math.atan2(2 * q1.y * q1.w - 2 * q1.x * q1.z, sqx - sqy - sqz + sqw);
                attitude = Math.asin(2 * test / unit);
                bank = Math.atan2(2 * q1.x * q1.w - 2 * q1.y * q1.z, -sqx + sqy - sqz + sqw)
            }
            pitchYawRoll.z = Math.floor(attitude * 1000) / 1000;
            pitchYawRoll.y = Math.floor(heading * 1000) / 1000;
            pitchYawRoll.x = Math.floor(bank * 1000) / 1000;
            return pitchYawRoll;
        }


        // Then, if I want the specific yaw (rotation around y), I pass the results of
        // pitchYawRoll.y into the following to get back the angle in radians which is
        // what can be set to the object's rotation.

        //*********************************************************
        function eulerToAngle(rot) {
            var ca = 0;
            if (rot > 0) {
                ca = (Math.PI * 2) - rot;
            } else {
                ca = -rot
            }

            return (ca / ((Math.PI * 2) / 360)); // camera angle radians converted to degrees
        }




        function animate() {

            requestAnimationFrame(animate);

            var T = clock.getDelta();
            timeS = timeS + T;
            // requestAnimationFrame默认调用render函数60次，通过时间判断，降低renderer.render执行频率
            if (timeS > renderT) {
                // 控制台查看渲染器渲染方法的调用周期，也就是间隔时间是多少
                //  console.log(`调用.render时间间隔`,timeS*1000+'毫秒');
                renderer.render(scene, camera); //执行渲染操作
                //renderer.render每执行一次，timeS置0
                timeS = 0;
                stats.update();



                // 2d屏幕的POI位置
                var vec = new THREE.Vector3(POIs.tags[0].pos.x, POIs.tags[0].pos.y,
                    POIs.tags[0].pos.z);
                vec.project(camera);
                // console.log('0', vec);
            }



            let t1 = new Date(); //本次时间
            let t = t1 - t0; // 时间差
            if (onoff == 1) {
                if (v != 0 && CONTROL_VCAM_DIRECT) {
                    //     camera.rotateX(v * t * Math.PI/4000);
                    //     console.log(eulerToAngle(quatToEuler(camera.quaternion).x))
                }
                if (h != 0 && CONTROL_VCAM_DIRECT) {

                    //  camera.rotateY(h * 0.001 * t / 3);
                    //  camera.rotateOnAxis(new THREE.Vector3(0, 1, 0),h* degInRad(0.5));
                    //  camera.lookAt(scene.position);

                    // var quaternion = new THREE.Quaternion();
                    // quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), h * t * Math.PI / 2000);
                    // camera.quaternion.multiplyQuaternions(quaternion, camera.quaternion);

                    //   camera.rotateOnWorldAxis(new THREE.Vector3(0,1,0), h*t*Math.PI/2000);
                    //   console.log(eulerToAngle(quatToEuler(camera.quaternion).y))

                }

            }
            t0 = t1;
            //  console.log(camera.rotation);
        }

        // 坐标系转换 84 -> 笛卡尔
        function processPOIs(poi_array) {

            // 相机笛卡尔坐标系
            for (let i = 0; i < poi_array.cameras.length; i++) {
                //console.log(poi_array.cameras[i]);
                var cam = poi_array.cameras[i];

                var pos = millerXY(cam.lon, cam.lat)

                cam.pos.x = pos.x; // x
                cam.pos.z = pos.y; // z<=y
                cam.pos.y = cam.height; // y<=z

                console.log(cam.pos);

            }

            // tag点笛卡尔坐标系
            for (let i = 0; i < poi_array.tags.length; i++) {
                //console.log(poi_array.cameras[i]); var
                tag = poi_array.tags[i];

                var pos = millerXY(tag.lon, tag.lat);

                tag.pos.x = pos.x; // x
                tag.pos.z = pos.y; // z<=y 
                tag.pos.y = tag.height; // y<=z 

                console.log(tag.pos);
            }
        }

        // add POI in scene
        function addPOI(poi_array) {

            const SCALE = 1;
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.25, 8000);
            var poi_cam = POIs.cameras[0];

            camera.position.set(poi_cam.pos.x / SCALE, poi_cam.pos.y / SCALE, poi_cam.pos.z / SCALE);


            camera.lookAt(new THREE.Vector3(poi_array.tags[0].pos.x / SCALE, poi_array.tags[0].pos.y / SCALE,
                poi_array.tags[0].pos.z / SCALE));

            console.log('addcam:', poi_cam.pos.x / SCALE, poi_cam.pos.y / SCALE, poi_cam.pos.z / SCALE)


            for (let i = 0; i < poi_array.tags.length; i++) {
                var tag = poi_array.tags[i];

                var geometry = new THREE.BoxGeometry(1, 1, 1);
                var material = new THREE.MeshBasicMaterial({
                    color: 0xffff7c,
                    //wireframe: true,
                    wireframeLinewidth: 1
                });
                var cube = new THREE.Mesh(geometry, material);
                cube.position.set(tag.pos.x / SCALE, tag.pos.y / SCALE, tag.pos.z / SCALE);
                console.log('addtag:', tag.pos.x / SCALE, tag.pos.y / SCALE, tag.pos.z / SCALE)
                scene.add(cube);

                var spritey = makeTextSprite(tag.text, {
                    fontsize: 22,
                    fontface: "Georgia",
                    borderColor: {
                        r: 0,
                        g: 0,
                        b: 255,
                        a: 1.0
                    }
                });
                spritey.position.set(tag.pos.x / SCALE, tag.pos.y / SCALE, tag.pos.z / SCALE);
                scene.add(spritey);
            }


        }

        function makeTextSprite(message, parameters) {
            if (parameters === undefined) parameters = {};
            var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
            var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
            var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
            var borderColor = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : {
                r: 0,
                g: 0,
                b: 0,
                a: 1.0
            };
            var backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : {
                r: 255,
                g: 255,
                b: 255,
                a: 1.0
            };
            var textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : {
                r: 255,
                g: 1,
                b: 1,
                a: 1.0
            };

            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            context.font = "Bold " + fontsize + "px " + fontface;
            var metrics = context.measureText(message);
            var textWidth = metrics.width;

            context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b +
                "," +
                backgroundColor.a + ")";
            context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," +
                borderColor.a +
                ")";

            context.lineWidth = borderThickness;
            /* roundRect(context, borderThickness / 2, borderThickness / 2, (textWidth + borderThickness) * 1.1, fontsize *
                1.4 +
                borderThickness, 8);
*/
            context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";
            context.fillText(message, borderThickness, fontsize + borderThickness);

            var texture = new THREE.Texture(canvas)
            texture.needsUpdate = true;

            var spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                // useScreenCoordinates: false
            });
            var sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.5 * fontsize, 0.25 * fontsize, 0.75 * fontsize);
            return sprite;
        }

        // lon 经度，西经为负数
        // lat 纬度，南纬是负数
        function millerXY(lon, lat) {

            var L = 6381372 * Math.PI * 2, // 地球周长
                W = L, // 平面展开后，x轴等于周长
                H = L / 2, // y轴约等于周长一半
                mill = 2.3, // 米勒投影中的一个常数，范围大约在正负2.3之间
                x = lon * Math.PI / 180, // 将经度从度数转换为弧度
                y = lat * Math.PI / 180; // 将纬度从度数转换为弧度

            // 这里是米勒投影的转换
            y = 1.25 * Math.log(Math.tan(0.25 * Math.PI + 0.4 * y));

            // 这里将弧度转为实际距离
            x = (W / 2) + (W / (2 * Math.PI)) * x;
            y = (H / 2) - (H / (2 * mill)) * y;
            // 转换结果的单位是公里
            // 可以根据此结果，算出在某个尺寸的画布上，各个点的坐标

            return {
                x: x,
                y: y
            };

        }

        function toScreenPos(vec) {
            var p = new THREE.Vector3(vec.x, vec.y, vec.z);
            //   console.log(p);

            var vector = p.project(camera);

            console.log(vector);

            vector.x = (vector.x + 1) / 2 * renderer.context.canvas.width;
            vector.y = -(vector.y - 1) / 2 * renderer.context.canvas.height;
            //console.log(renderer.context.canvas);

            console.log('screen pos:', vector);
            return vector;
        }
    </script>

</body>

</html>