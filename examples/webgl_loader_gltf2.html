<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - glTF loader</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            color: #fff;
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
        }

        #info a {
            color: #75ddc1;
            font-weight: bold;
        }
    </style>
</head>

<body>


    <script src="../build/three.js"></script>

    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/loaders/GLTFLoader.js"></script>

    <script src="js/Detector.js"></script>
    <script src="js/libs/stats.min.js"></script>

    <!-- 兴趣点数据 -->
    <script src="./POI.js"></script>

    <!-- 84坐标系转笛卡尔坐标系 -->
    <script src="./geodecy.js"></script>


    <script>
        if (!Detector.webgl) Detector.addGetWebGLMessage();

        var container, stats, controls;
        var camera, scene, renderer, light;
        var mixer = null;
        var deg = 0;
        var t0;

        var clock = new THREE.Clock();

        console.log(POIs);
        processPOIs(POIs);

        init();
        animate();

        function init() {
            t0 = new Date();

            container = document.createElement('div');
            document.body.appendChild(container);






            scene = new THREE.Scene();

            // envmap
            var path = 'textures/cube/Bridge2/';
            var format = '.jpg';
            var envMap = new THREE.CubeTextureLoader().load([
                path + 'posx' + format, path + 'negx' + format,
                path + 'posy' + format, path + 'negy' + format,
                path + 'posz' + format, path + 'negz' + format
            ]);

            scene = new THREE.Scene();
            scene.background = envMap;

            light = new THREE.HemisphereLight(0xbbbbff, 0x444422);
            light.position.set(0, 1, 0);
            scene.add(light);


            // model

            var loader = new THREE.GLTFLoader();
            loader.load('./gltf/congdianzhuang_out/congdianzhuang.gltf', function (gltf) {

                gltf.scene.traverse(function (child) {

                    if (child.isMesh) {
                        //   var texture = THREE.ImageUtils.loadTexture('./gltf/Charging.jpg');
                        //   texture.flipY = false;
                        //   child.material.map = texture;
                        //child.material.envMap = envMap;
                    }

                });

                scene.add(gltf.scene);

                mixer = new THREE.AnimationMixer(gltf.scene);
                //mixer.clipAction( gltf.animations[ 0 ])
                mixer.clipAction(gltf.animations[0]).loop = THREE.LoopOnce;
                //  mixer.clipAction(gltf.animations[0]).play();

            });

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.gammaOutput = true;
            container.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);
            addPOI(POIs);
            // stats
            stats = new Stats();
            container.appendChild(stats.dom);

            window.addEventListener('keydown', keyPressed, false);
            window.addEventListener('keyup', keyUp, false);

        }

        var onoff = 0;
        var h, v;

        function keyUp(e) {
            //     console.log('key up');
            onoff = 0;
            v = h = 0;
        }


        function keyPressed(e) {
            // console.log('key press');
            onoff = 1;
            var key = event.keyCode;
            switch (key) {

                case 87:
                    /*w*/
                    v = 1;
                    break;

                case 65:
                    /*a*/
                    h = 1;
                    break;

                case 83:
                    /*s*/
                    v = -1;
                    break;
                case 68:
                    /*d*/
                    h = -1;

                    break;
            }
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        //



        function animate() {

            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            stats.update();

            var delta = clock.getDelta();
            if (mixer != null) {
                mixer.update(delta);
            }



            // 2d屏幕的POI位置
            var vec = new THREE.Vector3(POIs.tags[0].pos.x, POIs.tags[0].pos.y,
                POIs.tags[0].pos.z);
            vec.project(camera);
            //  console.log('0', vec);


            let t1 = new Date(); //本次时间
            let t = t1 - t0; // 时间差
            if (onoff == 1) {
                if (v != 0) {
                    camera.rotateX(v * 0.001 * t / 3);
                }
                if (h != 0) {
                    camera.rotateY(h * 0.001 * t / 3);


                    // camera.lookAt(scene.position);

                }

            }

            t0 = t1;

            //  console.log(camera.rotation);

        }

        // 坐标系转换 84 -> 笛卡尔
        function processPOIs(poi_array) {

            // 相机笛卡尔坐标系
            for (let i = 0; i < poi_array.cameras.length; i++) {
                //console.log(poi_array.cameras[i]);
                var cam = poi_array.cameras[i];

                var pos = millerXY(cam.lon, cam.lat)

                cam.pos.x = pos.x; // x
                cam.pos.z = pos.y; // z<=y
                cam.pos.y = cam.height; // y<=z

                console.log(cam.pos);

            }

            // tag点笛卡尔坐标系
            for (let i = 0; i < poi_array.tags.length; i++) {
                //console.log(poi_array.cameras[i]); var
                tag = poi_array.tags[i];

                var pos = millerXY(tag.lon, tag.lat);

                tag.pos.x = pos.x; // x
                tag.pos.z = pos.y; // z<=y 
                tag.pos.y = tag.height; // y<=z 

                console.log(tag.pos);
            }
        }

        // add POI in scene
        function addPOI(poi_array) {

            const SCALE = 1;
            camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.25, 8000);
            var poi_cam = POIs.cameras[0];

            camera.position.set(poi_cam.pos.x / SCALE, poi_cam.pos.y / SCALE, poi_cam.pos.z / SCALE);


            camera.lookAt(new THREE.Vector3(poi_array.tags[0].pos.x / SCALE, poi_array.tags[0].pos.y / SCALE,
                poi_array.tags[0].pos.z / SCALE));

            console.log('addcam:', poi_cam.pos.x / SCALE, poi_cam.pos.y / SCALE, poi_cam.pos.z / SCALE)


            for (let i = 0; i < poi_array.tags.length; i++) {
                var tag = poi_array.tags[i];

                var geometry = new THREE.BoxGeometry(1, 1, 1);
                var material = new THREE.MeshBasicMaterial({
                    color: 0xffff7c,
                    //wireframe: true,
                    wireframeLinewidth: 1
                });
                var cube = new THREE.Mesh(geometry, material);
                cube.position.set(tag.pos.x / SCALE, tag.pos.y / SCALE, tag.pos.z / SCALE);
                console.log('addtag:', tag.pos.x / SCALE, tag.pos.y / SCALE, tag.pos.z / SCALE)
                scene.add(cube);

                var spritey = makeTextSprite(tag.text, {
                    fontsize: 22,
                    fontface: "Georgia",
                    borderColor: {
                        r: 0,
                        g: 0,
                        b: 255,
                        a: 1.0
                    }
                });
                spritey.position.set(tag.pos.x / SCALE, tag.pos.y / SCALE, tag.pos.z / SCALE);
                scene.add(spritey);
            }


        }

        function makeTextSprite(message, parameters) {
            if (parameters === undefined) parameters = {};
            var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
            var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
            var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
            var borderColor = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : {
                r: 0,
                g: 0,
                b: 0,
                a: 1.0
            };
            var backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : {
                r: 255,
                g: 255,
                b: 255,
                a: 1.0
            };
            var textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : {
                r: 255,
                g: 1,
                b: 1,
                a: 1.0
            };

            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            context.font = "Bold " + fontsize + "px " + fontface;
            var metrics = context.measureText(message);
            var textWidth = metrics.width;

            context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b +
                "," +
                backgroundColor.a + ")";
            context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," +
                borderColor.a +
                ")";

            context.lineWidth = borderThickness;
            /* roundRect(context, borderThickness / 2, borderThickness / 2, (textWidth + borderThickness) * 1.1, fontsize *
                1.4 +
                borderThickness, 8);
*/
            context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";
            context.fillText(message, borderThickness, fontsize + borderThickness);

            var texture = new THREE.Texture(canvas)
            texture.needsUpdate = true;

            var spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                // useScreenCoordinates: false
            });
            var sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.5 * fontsize, 0.25 * fontsize, 0.75 * fontsize);
            return sprite;
        }

        // lon 经度，西经为负数
        // lat 纬度，南纬是负数
        function millerXY(lon, lat) {

            var L = 6381372 * Math.PI * 2, // 地球周长
                W = L, // 平面展开后，x轴等于周长
                H = L / 2, // y轴约等于周长一半
                mill = 2.3, // 米勒投影中的一个常数，范围大约在正负2.3之间
                x = lon * Math.PI / 180, // 将经度从度数转换为弧度
                y = lat * Math.PI / 180; // 将纬度从度数转换为弧度

            // 这里是米勒投影的转换
            y = 1.25 * Math.log(Math.tan(0.25 * Math.PI + 0.4 * y));

            // 这里将弧度转为实际距离
            x = (W / 2) + (W / (2 * Math.PI)) * x;
            y = (H / 2) - (H / (2 * mill)) * y;
            // 转换结果的单位是公里
            // 可以根据此结果，算出在某个尺寸的画布上，各个点的坐标

            return {
                x: x,
                y: y
            };

        }

        function toScreenPos(vec) {
            var p = new THREE.Vector3(vec.x, vec.y, vec.z);
            //   console.log(p);

            var vector = p.project(camera);

            console.log(vector);

            vector.x = (vector.x + 1) / 2 * renderer.context.canvas.width;
            vector.y = -(vector.y - 1) / 2 * renderer.context.canvas.height;
            //console.log(renderer.context.canvas);

            console.log('screen pos:', vector);
            return vector;
        }
    </script>

</body>

</html>